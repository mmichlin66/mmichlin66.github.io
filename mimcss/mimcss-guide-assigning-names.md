---
layout: mimcss-guide
unit: 4
title: "Mimcss Guide: Assigning Names"
---

# Mimcss Guide: Assigning Names

We already mentioned that the names you use when referring to your classes, IDs, animations and custom properties are not the names that are actually used in HTML. The actual names are auto-generated by Mimcss, which ensures that they are unique.

Mimcss has two modes of assigning names and both ensure that they are unique within your application.

The first mode is called **Scoped**. It creates names that combine the name of the class that defines the property and the name of the property itself. This method produces names that clearly refer to the place where they were defined and, therefore, this method should be used during development.

The second method of assigning names is called **Unique**. It creates names by appending an incrementally increasing number to a prefix. The default prefix is `"n"` but it can be changed programmatically. This method produces short names without a real possibility to relate back to the place in the code where they were defined; therefore, this method should be used for release builds.

The default mode is **Scoped**. In order to switch to the Unique mode, the application should call the Mimcss's `useOptimizedStyleNames` function. This function accepts an optional `prefix` parameter that can specify the prefix to be used for generating unique names. The `useOptimizedStyleNames` function must be called very early in the application life because the mode must be set before any style definition classes are processed.

## Name Scoping
Different classes can define properties with identical names and they will be unique when applied to HTML. We call it *name scoping*, which means that names are scoped to the style definition classes.

Consider the following example, where we have two classes (that might be coming from different libraries):

```tsx
/* MyStyles.ts */
export class MyStyles
{
    emphasized = $class({ color: "red", fontWeight: 700 });
});

/* OtherStyles.ts */
export class OtherStyles
{
    emphasized = $class({ color: "orange", fontStyle: "italic" });
});

/* MyComponent.tsx */
import {MyStyles} from "./MyStyles"
import {OtherStyles} from "./OtherStyles"

let myStyles = $activate(MyStyles);
let otherStyles = $activate(OtherStyles);

render()
{
    return <div>
        <p className={myStyles.classes.emphasized}>Hello!</p>
        <p className={otherStyles.classes.emphasized}>Hello!</p>
   </div>
```

Although the names of the properties defining the CSS classes are the same, Mimcss will use different names when creating CSS rules and inserting them into the DOM.

Under the Scoped mode, the string value of the `myStyles.classNames.emphasized` property will be `".MyStyles_emphasized"`, while the string value of the `otherStyles.classNames.emphasized` property will be `".OtherStyles_emphasized"`. Under the Unique mode, the names might be created as `n25` and `n73`. This would be obviously much more difficult to debug.

## Names in Grouping Rules
Conditional grouping rules such as @media and @supports posit a different problem. Names of classes defined under these grouping rules are supposed to match those defined outside the conditions, so that style values defined within the grouping rules will take effect when the conditions evaluate to true. Consider the following example:

```tsx
class MyStyles
{
    box = $class( { margin: 8 })

    ifSmallScreen = $media( { maxWidth: 600 }, {
        box: $class({ margin: 4 })
    })
}

let myStyles = $activate(MyStyles);

render()
{
    return <div>
        <p className={myStyles.classes.box}>Hello!</p>
   </div>
```

We have two properties named `box`: the first one is defined at the top level of the class definition, and the second one - inside the @media rule. The names assigned by Mimcss must be the same for both properties. Mimcss solves this problem with a simple convention: within the same style definition class, if a grouping rule is assigned to a property with the same name as the property at the top level, the same actual name will be assigned to them.

In the example above, when Mimcss processes the `MyStyle` the `box` property gets assigned a name first. When the second `box` property is encountered, Mimcss finds this name at the top level and assigns it to the second property too.

## Explicit Names
There are situations when we need to bypass the Mimmcss's name auto-generation. One use case is when we want to override a name that comes from a CSS file (remember that Mimcss is not "all-or-nothing" library). In this case, we can specify the names explicitly. The functions that produce named rules - `$class`, `$id`, `$custom` and `$animation` - accept an optional parameter where we can provide the name as a string. For example,

```tsx
class MyStyles
{
    box = $class( { margin: 8 }, "box-class-name")
}
```

Another use case is when we have an external style definition class and we want to override one of the named rules defined there. To accomplish this, we use the same optional parameter - but this time we pass the rule object to it:

```tsx
// the 'LibStyles' class from the 'lib' library has a class assigned to property 'box'
import {LibStyles} from "lib"

class MyStyles
{
    lib = $use(LibStyles)

    box = $class( { margin: 8 }, this.lib.box)

}
```








